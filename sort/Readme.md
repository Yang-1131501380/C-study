# C++ std::sort 总结与使用注意事项

## 一、概述

`std::sort` 是 C++ 标准库 `<algorithm>` 头文件提供的通用排序函数，用于对序列进行高效排序。其底层采用混合排序算法（通常为 introsort，结合快速排序、堆排序和插入排序），平均时间复杂度为 **O(n log n)**，是处理排序任务的高效工具。

## 二、基本语法

```cpp
// 默认升序排序
std::sort(first, last);

// 自定义比较规则排序
std::sort(first, last, comparator);
```

### 参数说明：

- `first`：指向序列第一个元素的随机访问迭代器
- `last`：指向序列最后一个元素**后一位**的随机访问迭代器（排序范围为 `[first, last)`，左闭右开）
- `comparator`：可选参数，用于定义排序规则的比较器（函数、lambda 表达式或函数对象）

## 三、支持的场景

1. **容器类型**：
   - 标准容器：`vector`、`array`、`deque` 等（需支持随机访问迭代器）
   - C 风格数组（通过指针操作）
2. **数据类型**：
   - 基本类型：`int`、`float`、`double`、`char`、`std::string` 等
   - 自定义类型：结构体、类（需提供比较规则）

## 四、常用排序方式

| 排序方式             | 实现方法                               | 示例代码                                                     |
| -------------------- | -------------------------------------- | ------------------------------------------------------------ |
| 升序排序（默认）     | 依赖元素的 `<` 运算符                  | `std::sort(v.begin(), v.end());`                             |
| 降序排序             | 使用 `std::greater<T>()` 标准比较器    | `std::sort(v.begin(), v.end(), std::greater<int>());`        |
| 自定义规则（函数）   | 通过函数指针指定比较逻辑               | `std::sort(v.begin(), v.end(), compareFunc);`                |
| 自定义规则（lambda） | 通过 lambda 表达式定义比较逻辑（推荐） | `std::sort(v.begin(), v.end(), [](a, b) { return a.prop < b.prop; });` |

## 五、使用注意事项

1. **迭代器限制**：

   - 仅支持**随机访问迭代器**，不支持 `list`、`forward_list` 等双向迭代器容器（这类容器需使用自身的 `sort()` 成员函数）。

2. **排序范围**：

   - 严格遵循 `[first, last)` 左闭右开原则，避免越界访问（如排序数组前 5 个元素：`sort(arr, arr + 5)`）。

3. **稳定性问题**：

   - `std::sort` 是**不稳定排序**，相等元素的相对顺序可能在排序后改变。
   - 若需保持相等元素的原始顺序，应使用 `std::stable_sort`。

4. **比较器设计**：

   - 必须满足

     严格弱序

     （strict weak ordering）：

     - 非自反性：`comp(a, a)` 必须返回 `false`
     - 反对称性：若 `comp(a, b) = true`，则 `comp(b, a) = false`
     - 传递性：若 `comp(a, b) = true` 且 `comp(b, c) = true`，则 `comp(a, c) = true`

   - 禁止在比较器中修改元素值（会导致未定义行为）。

5. **性能考量**：

   - 对小规模数据（n < 15），效率与简单排序算法（如插入排序）接近。
   - 大规模数据排序时，性能优于手工实现的普通排序算法。
   - 避免对同一序列重复排序，可添加状态标记优化。

6. **异常安全**：

   - 若比较操作不抛出异常，则 `std::sort` 是异常安全的；否则可能导致序列状态不确定。

7. **函数选择建议**：

   - 需稳定排序 → `std::stable_sort`
   - 仅需前 n 个元素有序 → `std::partial_sort`
   - 仅需确定第 n 大元素位置 → `std::nth_element`

## 六、最佳实践

1. 优先使用 `std::sort` 而非手工实现排序算法，平衡效率与可读性。
2. 对自定义类型，推荐使用 lambda 表达式定义比较规则（代码更紧凑）。
3. 排序前确保迭代器有效且范围正确，避免访问越界。
4. 对大型容器，排序前预留足够容量（避免排序中触发内存重新分配）。
5. 多次排序相同类型元素时，可封装比较器为函数对象提高复用性。